#[cfg(test)]
#[cfg(feature = "test_access")]
pub mod processor {
    use std::{ fs::File, io::Read, path::Path };

    use atp_project::{
        builder::{ atp_builder::AtpBuilder, atp_processor::{ AtpProcessor, AtpProcessorMethods } },
        token_data::{ token_defs::{ atb::Atb, ate::Ate, raw::Raw, rpt::Rpt }, TokenMethods },
    };
    use uuid::Uuid;

    #[test]
    fn test_process_all() {
        let (mut processor, identifier) = AtpBuilder::new()
            .add_to_beginning("Banana")
            .add_to_end("Laranja")
            .repeat(3 as usize)
            .build();
        let input = "Carimbo verde de deus";

        let output = processor.process_all(&identifier, input).unwrap();

        let expected_output =
            "BananaCarimbo verde de deusLaranjaBananaCarimbo verde de deusLaranjaBananaCarimbo verde de deusLaranja";

        assert_eq!(output, expected_output, "Unexpected output in process_all");
    }
    #[test]
    fn test_process_all_with_debug() {
        let (mut processor, identifier) = AtpBuilder::new()
            .add_to_beginning("Banana")
            .add_to_end("Laranja")
            .repeat(3 as usize)
            .build();
        let input = "Carimbo verde de deus";

        let output = processor.process_all_with_debug(&identifier, input).unwrap();

        let expected_output =
            "BananaCarimbo verde de deusLaranjaBananaCarimbo verde de deusLaranjaBananaCarimbo verde de deusLaranja";

        assert_eq!(output, expected_output, "Unexpected output in process_all");
    }

    #[test]
    fn test_process_single() {
        let mut processor = AtpProcessor::new();
        let token: Box<dyn TokenMethods> = Box::new(Raw::params("a", "b").unwrap());

        let input = "a".repeat(100);

        let output = processor.process_single(token, &input).unwrap();

        let expected_output = "b".repeat(100);

        assert_eq!(output, expected_output);
    }
    #[test]
    fn test_process_single_with_debug() {
        let mut processor: Box<dyn AtpProcessorMethods> = Box::new(AtpProcessor::new());
        let token: Box<dyn TokenMethods> = Box::new(Raw::params("a", "b").unwrap());

        let input = "a".repeat(100);

        let output = processor.process_single_with_debug(token, &input).unwrap();

        let expected_output = "b".repeat(100);

        assert_eq!(output, expected_output);
    }

    #[test]
    fn test_read_from_file() {
        let mut processor = AtpProcessor::new();

        let identifier = processor.read_from_text_file(Path::new("instructions.atp")).unwrap();

        let input_string = "Banana";
        let expected_output = "Bznzn";

        let output = processor.process_all(&identifier, input_string).unwrap();

        println!("{} => {} == {}", input_string, output, expected_output);

        assert_eq!(output, expected_output, "Unexpected Output in read_from_file");
    }

    #[test]
    fn test_write_to_file() {
        let file = tempfile::NamedTempFile::new().expect("Error opening archive");

        let path = file.path();

        let (mut processor, identifier) = AtpBuilder::new()
            .add_to_beginning("Banana")
            .add_to_end("Laranja")
            .repeat(3 as usize)
            .build();

        let _ = processor.write_to_text_file(&identifier, path);

        let mut opened_file = File::open(path).unwrap();

        let mut content = String::new();
        opened_file.read_to_string(&mut content).unwrap();

        let expected_content = "atb Banana;\nate Laranja;\nrpt 3;\n";

        assert_eq!(
            content,
            expected_content,
            "Unexpected Output in test_write_to_file: content differs"
        );
    }

    #[test]
    fn test_add_transform() {
        use uuid::Variant;
        let mut tokens: Vec<Box<dyn TokenMethods>> = Vec::new();

        tokens.push(Box::new(Atb::params("Banana")));
        tokens.push(Box::new(Ate::params("Laranja")));
        tokens.push(Box::new(Rpt::params(3)));

        let mut processor = AtpProcessor::new();

        let identifier = processor.add_transform(tokens);

        let parsed = Uuid::parse_str(&identifier).expect(
            "Unexpected output in test_add_transform: Non valid UUID generated by add_transform"
        );

        assert_eq!(
            parsed.get_variant(),
            Variant::RFC4122,
            "Unexpected output in test_add_transform: Non UUID_V4"
        );
        assert_eq!(
            parsed.get_version_num(),
            4 as usize,
            "Unexpected output in test_add_transform: UUID is from different version"
        );
    }
}
